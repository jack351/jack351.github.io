{"pages":[],"posts":[{"title":"Java类排序方法","text":"Java中实现类排序的两种方法1、内部比较器：这个类实现接口Comparable，重写compareTo()方法，实现比较逻辑(1)写一个类实现Comparable接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Student implements Comparable&lt;Student&gt; { private String name; private String sex; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Student(String name, String sex, int age) { super(); this.name = name; this.sex = sex; this.age = age; } @Override public String toString() { return \"Student [name=\" + name + \", sex=\" + sex + \", age=\" + age + \"]\"; } @Override public int compareTo(Student o) { return this.age-o.age; } } （2）客户端实现1234567891011121314151617public static void main(String[] args) { List&lt;Student&gt;students=new ArrayList&lt;Student&gt;(); Student s1=new Student(\"lisi1\", \"nan1\", 18); Student s2=new Student(\"lisi2\", \"nan2\", 30); Student s3=new Student(\"lisi3\", \"nan3\", 17); Student s4=new Student(\"lisi4\", \"nan4\", 22); students.add(s1); students.add(s2); students.add(s3); students.add(s4); System.out.println(\"未排序前：\"+students); Collections.sort(students); System.out.println(\"排序后：\"+students); } 2、外部比较器：为这个类定义多个Comparator实现类，重写compare()方法，实现不同的比较逻辑（1）实现Compare接口123456789public class StudentConparator implements Comparator&lt;Student&gt; { @Override public int compare(Student o1, Student o2) { return o1.getAge()-o2.getAge(); }} (2) 客户端实现1234567891011121314151617public static void main(String[] args) { List&lt;Student&gt;students=new ArrayList&lt;Student&gt;(); Student s1=new Student(\"lisi1\", \"nan1\", 18); Student s2=new Student(\"lisi2\", \"nan2\", 30); Student s3=new Student(\"lisi3\", \"nan3\", 17); Student s4=new Student(\"lisi4\", \"nan4\", 22); students.add(s1); students.add(s2); students.add(s3); students.add(s4); System.out.println(\"未排序前：\"+students); Collections.sort(students,new StudentComparator()); System.out.println(\"排序后：\"+students); }","link":"/2019/11/16/Java%E7%B1%BB%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/"},{"title":"Sring Boot入门笔记","text":"第一部分1、Spring简介 首先是由pivotal团队开发的全新框架，其设计目的是为了简化新的Spring的初始搭建以及开发过程，并且该框架使用了特定的方式来进行配置，这也使得开发人员不用再去定义模板化的配置了 2、微服务即大变小，一个整体划分若干个小的服务，其中可以通过HTTP的方式进行互通，并且每个功能元素终都是一个可以独立替换和升级的软件单元 3.环境准备 un-ordered list jdk1.8 maven 3.x :maven3.3以上 IDEA2017 SpringBoot 1.5.9RELEASE 第二部分第一个Spring Boot 的 Hello World1、创建一个Maven工程2、导入相关的依赖包 具体根据自己的所需导入 3、编写主程序12345@SpringBootApplication public class SpringBoot01HelloQuickApplication { public static void main(String[] args) { SpringApplication.run(SpringBoot01HelloQuickApplication.class,args); } } 4、编写相应的测试代码12345678@Controller public class HelloController { @ResponseBody @RequestMapping(&quot;/hello&quot;) public String hello(){ return &quot;hello world&quot;; } } 5、运行主机程序进行测试访问 localhost:8080/hello(根据自己的requetsMapping地址的进行请求) 6、@SpringBootApplication注解 用于说明这个类是SpringBoot的主配置类 进入SpringBootApplication注解，可以看到有多个注解构成SpringBootApplication1234567891011@Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter(type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) 第三部分springboot常用注解1、@Configuration用于来标注一个类为SpringBoot的一个配置类，相当于SSM框架的XML文件，只不过这里都用Java代码来实现属性的注入而已2、@Bean(“dataSource”)用来标注一个具体的Bean，例如：12345678910 @Bean(&quot;dataSource&quot;)@ResponseBodypublic DataSource getDataSource(){ DriverManagerDataSource datasource=new DriverManagerDataSource(); datasource.setDriverClassName(driverClassName); datasource.setUrl(url); datasource.setUsername(userName); datasource.setPassword(userPasswoord); return datasource;} 3、@Value用来对属性注入值的 4、@Import(Test.class)用来具体引入另一个配置文件，即用@Configuration标注的类，例如我配置了另一个类为Test: 12345678910111213@Configurationpublic class Test { @Bean(&quot;user&quot;) @ResponseBody public User getUser(){ User user=new User(); user.setId(&quot;jack&quot;); user.setPassword(&quot;233&quot;); user.setRole(this.getRole()); return user; } 5、@PropertySource(“classpath:jdbc.properties”) 用来指定引入自定义的properties配置文件，既然说到properties配置文件了，那这里就提一下怎么获取properties里面设置的属性值吧 可以用SpringEl表达式获取，如properties文件里面写：1jab.userName=liuwei000 则可以${jab.userName}获取 批量注入6、@ConfigurationProperties(prefix=”property.user”)用于批量注入属性值，prefix为properties为属性配置的前缀其中属性值要与类的属性一致，如：123456789101112131415161718192021222324252627282930@Configuration@ConfigurationProperties(prefix=&quot;property.user&quot;)public class UserProperty { private String userName; private String userPwd; public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } public String getUserPwd() { return userPwd; } public void setUserPwd(String userPwd) { this.userPwd = userPwd; } @Override public String toString() { return &quot;UserProperty [userName=&quot; + userName + &quot;, userPwd=&quot; + userPwd + &quot;]&quot;; } } properties里面：12property.user.userName=zs001property.user.userPwd=111111 7、@Profile()用于来选则具体类的实例，当然properties配置文件也要有相对应的标识，配置文件加了这一句spring.profiles.active=adv我定义了两个类，具体如下12345678910@Service@Profile(&quot;adv&quot;)public class SpringDevFilesevice2 implements ProfileService { @Override public void getWrite() { System.out.println(&quot;我正在调用Dev的方法&quot;); } 12345678910@Service@Profile(&quot;pro&quot;)public class SpringProFilesevice implements ProfileService { @Override public void getWrite() { System.out.println(&quot;我正在调用Pro的方法&quot;); } 接口：12345public interface ProfileService { public void getWrite();} 测试类内容12345678 @Autowiredprivate ProfileService ps; public void run(String... args) throws Exception { ps.getWrite(); } 8、最后补充两点： CommandLineRunner继承这个接口后实现里面的方法，当主配置类运行完后，即可运行此重写方法里面的方法体，实例12345678910111213141516171819202122 @Componentpublic class SpringBootInit implements CommandLineRunner{ /*@Autowired private UserProperty user;*/ @Autowired private ProfileService ps; @Autowired private Person person; @Override public void run(String... args) throws Exception { for(String arg:args){ System.out.println(&quot;参数列表:&quot;+arg); } /*System.out.println(&quot;初始化开始&quot;); System.out.println(user);*/ ps.getWrite(); System.out.println(person); 注：此为自己测试所用，所以有些注释 ExitCodeGenerator实现此接口可以在程序退出时执行重写的方法，示例代码：12345678public class SpringExit implements ExitCodeGenerator { @Override public int getExitCode() { System.out.println(&quot;退出程序&quot;); return 505; }} 测试代码1234567@RequestMapping(&quot;/exit.do&quot;) public void exit(){ int num=SpringApplication.exit(context,new SpringExit()); System.out.println(&quot;退出码：&quot;+num); }","link":"/2019/10/20/SpringBoot%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"},{"title":"Java基础笔记","text":"Java笔记整理第一章 Java程序开发1、常用的字符集​ ASCII （单字节） ​ ISO8859-1（单字节，ASCII的扩展） GB2312，GBK，Big5（双字节） Unicode ​ UTF-8（1-4字节，可变字节编码，兼容ASCII，中文占三个字节） ​ UTF-16（2字节） ​ UTF-32（4字节） Java语言使用Unicode字符集；Java中的字符串都用Unicode字符集编码；Java中的char类型占2个字节。 2、Java的跨平台性​ 跨平台性: 一处编写，处处运行。指的是用Java语言编写的程序，可以在各个操作系统上运行，不需要修改。 ​ 跨平台性的实现原理: Java源程序是解释执行的，每个平台上有不同版本的JVM，JVM负责把字节码文件（类文件）解释成符合当前平台规范的机器码 3、专业术语​ JVM：Java Virtual Machine，Java虚拟机 ​ JDK：Java Development Kit，Java开发工具包 ​ JRE：Java Runtime Environment，Java运行环境 第二章 数据类型与运算符1、数据类型​ 基本数据类型和引用类型 2、基本数据类型​ 数据类型 字节数 默认值 包装类 ​ byte 1字节 0 Byte ​ short 2字节 0 Short ​ int 4字节 0 Integer ​ long 8字节 0 Long ​ float 4字节 0.0f Float ​ double 8字节 0.0 Double ​ char 2字节 ‘’\\u0000 Charatcter boolean true/false false Boolean 3、 基本数据类型的显式和隐式转换​ 隐式转换（自动类型转换）: 范围小的可以直接转换为转换范围大的类型 显式转换（强制类型转换）: 范围大的不可以直接转换为转换范围小的类型,需要强制转换 4、Java内存的分布 堆、栈、常量池、方法区 5、基本数据类型和引用类型在内存存储上有什么区别 基本数据类型存在栈内存，引用类型的引用存在栈内存，内容存在堆内存； 基本数据类型用=直接赋值，引用类型使用new创建对象赋值。 6、自动装箱拆箱 装箱：基本数据类型转换为包装器类型，称为装箱（boxing）；例如，int型转换为Integer类型； 拆箱：包装器类型转换为基本数据类型，称为拆箱（unboxing）；例如Integer类型转换为int类型； 在自动装箱拆箱过程中，针对的是Byte,Short,Intger,Long,Character 只有数值是byte范围内的时候，才使 用到常量池，否则都是分配新的内存空间。 7、Java语言中的运算符 &amp;和&amp;&amp;，|和||作为逻辑运算符的区别？ &amp;和|称为非短路逻辑运算；&amp;&amp;和||称为短路逻辑运算。 第五章、面向对象1、面向对象的三特征面向对象的三个基本特征是：封装、继承、多态 封装：封装是将对象的信息隐藏在对象内部，禁止外部程序直接访问对象内部的属性，对外提供一个接口访问对象的属性。 通俗解释：Java的封装就是将属性私有化（private），对外提供一个公有（public）的getter和setter方法供外部来获得或者修改当前属性的值。 继承：通俗解释：子类继承父类，子类就拥有了父类的非私有（private）的属性和方法，同时子类可以扩展自己的属性和方法。 多态：不同类的对象对同一消息做出响应，即同一消息可以根据发送对象的不同而采用多种不同的行为方式。 成员访问控制符： private：只能在同一类中进行访问 default:同一包中的所有类都可以访问 protected:不同包中的子类才能访问 public：不同包非子类都可以访问 2、其他extends关键字：所有Java中的类都直接或间接继承自Object super关键字：可以在子类构造方法中显式调用父类的构造方法，该调用必须位于子类构造方 方法覆盖（override）：方法名相同参数列表也相同，主要是用于子类对父类的方法重写 方法重载(overload) : 方法名相同，但参数列表不同，主要用于在同一个类中 3、super和this有什么区别？​ this引用对象自身、调用自己的成员变量、方法或构造方法，而super调用父类定义的成员变量、方法或构造方法，super不能当作引用传递给其他的调用者而this可以。 4、final关键字修饰变量、成员方法和类的区别？1、final修饰变量时，该变量成为常量，不能重新进行赋值 2、final修饰方法时，说明该方法不能被子类覆盖 3、final修饰类时，说明该类无法被继承 5、接口与抽象类的区别抽象类： 1、有构造方法 2、可以有抽象方法也可以没有 3、单一继承 接口： 1、没构造方法 2、定义的方法都是抽象方法、定义的变量都是最终常量 3、可以多继承 第六章 垃圾回收Java垃圾回收机制：​ Java垃圾回收是一个自动运行的管理程序，运行时使用的内存的进程。通过GC的自动执行JVM将程序员从申请和释放内存的繁重操作中解放出来，垃圾回收机制的托管特性可以一定程度上保证程序的健壮性。 final\\finally\\finalize的区别是什么？1、首先回答final关键字修饰变量、成员方法和类的区别； 2、finally是异常处理中必须执行的代码块； 3、finalize是Object提供的当对象被垃圾回收器回收时执行的方法。 第七章 异常处理标准异常的顶级父类是Throwable，Throwable类有两个子类：Exception和Error。Exception与Error的区别？错误（Error）:错误程序没法处理，例如内存泄漏。发生错误后，一般虚拟机会选择终止程序运行； 异常（Exception）：异常指的是程序运行时发生的不正常事件；异常能够被程序处理，保证程序继续运行下去。 运行时异常和非运行时异常的区别？运行时异常：RuntimeException（非检测异常：unchecked Exception）： 在编译期不检测，程序中可以选择处理，也可以不处理，如果不处理运行时出现异常时会中断程序。 非运行时异常：（检测异常：checked Exception）： 必须进行处理的异常，如果不处理，将发生编译期错误。 处理异常有哪几种？1、通过try…catch…来进行捕获 2、通过throws往上继续抛，将当前的异常类型声明到当前的方法上面。 throw和throws的区别？ throw是手动抛出一个异常对象； throws放在方法声明上面，指定调用这个方法时，必须处理此异常。 自定义异常自己定义的异常类继承Exception及相关子类 总结Java对异常进行了分类，不同类型的异常分别用不同的Java类表示，所有异常的根类为java.lang.Throwable，Throwable下面又派生了两个子类：Error和Exception。 Exception又分为checked异常和unchecked异常，checked异常是编译器强制必须try..catch处理或用throws声明继续抛给上层调用方法处理，unchecked异常可以处理也可以不处理。 第八章 多线程进程与线程的关系进程是系统运行程序的基本单位，程序运行时就会产生一个进程，一个程序可以有多个进程； 线程是进程中执行运算的最小单位，线程可以共享进程的数据。 线程的生命周期1、新建状态：线程创建完成，处于新建状态 2、就绪状态：调用start()方法后，线程处于就绪状态，也就是说，线程正在等待获取cpu资源的机会，一旦别的线程运行完成后，退出cpu资源后，则此线程有机会进入cpu 3、运行状态：指线程获得了cpu资源 4、死亡状态：指线程工作已经完成 创建线程的几种方法1、继承Thread类 2、实现Runnable接口","link":"/2019/11/08/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"},{"title":"Idea中进行SpringBoot的分布式开发配置","text":"title:Idea中进行SpringBoot的分布式开发配置一、父工程1、pom.xml里面的配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.chinasofti&lt;/groupId&gt; &lt;artifactId&gt;chinasoftishop-parent&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;../chinasofti-usermanager&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring-boot.version&gt;2.1.5.RELEASE&lt;/spring-boot.version&gt; &lt;mybatis.version&gt;3.4.6&lt;/mybatis.version&gt; &lt;mybatis-spring-boot.version&gt;1.3.1&lt;/mybatis-spring-boot.version&gt; &lt;druid.version&gt;1.1.10&lt;/druid.version&gt; &lt;mysql-connector-java.version&gt;5.1.34&lt;/mysql-connector-java.version&gt; &lt;commons-io.version&gt;2.6&lt;/commons-io.version&gt; &lt;commons-fileupload.version&gt;1.3.3&lt;/commons-fileupload.version&gt; &lt;commons-codec.version&gt;1.10&lt;/commons-codec.version&gt; &lt;commons-lang3.version&gt;3.6&lt;/commons-lang3.version&gt; &lt;springfox-swagger.version&gt;2.7.0&lt;/springfox-swagger.version&gt; &lt;fastjson.version&gt;1.2.30&lt;/fastjson.version&gt; &lt;pagehelper.boot.version&gt;1.2.5&lt;/pagehelper.boot.version&gt; &lt;jjwt.version&gt;0.9.1&lt;/jjwt.version&gt; &lt;yaml.version&gt;1.23&lt;/yaml.version&gt; &lt;jackson.version&gt;2.9.6&lt;/jackson.version&gt; &lt;fastdfs-client.version&gt;1.26.6&lt;/fastdfs-client.version&gt; &lt;shiro.version&gt;1.4.0&lt;/shiro.version&gt; &lt;shiro-redis.version&gt;3.0.0&lt;/shiro-redis.version&gt; &lt;thymeleaf.extras.shiro.version&gt;2.0.0&lt;/thymeleaf.extras.shiro.version&gt; &lt;httpclient.version&gt;4.4&lt;/httpclient.version&gt; &lt;json.version&gt;20160212&lt;/json.version&gt; &lt;fastdfs-client.version&gt;1.26.6&lt;/fastdfs-client.version&gt; &lt;spring.data.solr.version&gt;2.1.1.RELEASE&lt;/spring.data.solr.version&gt; &lt;/properties&gt; &lt;!--test--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- Import dependency management from Spring Boot --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-boot.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-solr&lt;/artifactId&gt; &lt;version&gt;${spring.data.solr.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;${mysql-connector-java.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${mybatis-spring-boot.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${pagehelper.boot.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;${mybatis.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--阿里数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${druid.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;${commons-io.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;${commons-fileupload.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;${commons-codec.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;${commons-lang3.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;${springfox-swagger.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;${springfox-swagger.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;${jackson.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;${jjwt.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- yml解析器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.yaml&lt;/groupId&gt; &lt;artifactId&gt;snakeyaml&lt;/artifactId&gt; &lt;version&gt;${yaml.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.tobato&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt; &lt;version&gt;${fastdfs-client.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Shiro使用Srping框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;${shiro.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--shiro核心包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;${shiro.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Shiro使用Redis缓存框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.crazycake&lt;/groupId&gt; &lt;artifactId&gt;shiro-redis&lt;/artifactId&gt; &lt;version&gt;${shiro-redis.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--redis缓存--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;${spring-boot.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- thymeleaf模板引擎和shiro框架的整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;${thymeleaf.extras.shiro.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- httpclient --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;${httpclient.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- json 工具包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;${json.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 分布式存储客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.tobato&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt; &lt;version&gt;${fastdfs-client.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-solr&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 默认 starter 会加载 solrj 进来, 下面这个可不引--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.solr&lt;/groupId&gt; &lt;artifactId&gt;solr-solrj&lt;/artifactId&gt; &lt;version&gt;6.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;${spring-boot.version}&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 二、子工程的建立1、在父工程的基础上建立Maven工程 2、子工程pom.xml配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;chinasoftishop-parent&lt;/artifactId&gt; &lt;groupId&gt;com.chinasofti&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../chinasoftishop-parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;chinasofti-usermanager&lt;/artifactId&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- Import dependency management from Spring Boot --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-boot.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- SpringBoot Web容器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- SpringBoot 拦截器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 分页助手--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--阿里数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mysql 的驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- spring boot 的starter依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.26&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- yml解析器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.yaml&lt;/groupId&gt; &lt;artifactId&gt;snakeyaml&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3、在src/main/java中建立自己的五层架构注：当然五层架构不是绝对的，根据实际情况建立，我所建立的如下图 4、yml的配置注：可以用yml或者properties配置文件 4.1、application.yml配置123456789101112131415161718192021222324252627282930313233343536373839404142434445server: #服务端口 port: 8080 servlet: #项目contextpath context-path: / tomcat: # tomcat的uri编码 uri-encoding: UTF-8 # 配置tomcat最大的线程数 max-threads: 800 # 配置tomcat初始化线程数 min-spare-threads: 30# 日志信息配置logging: level: com.chinasofti: debug org.springframework: warn# spring 配置spring: application: name: chinasofti-usermanaer jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss# #配置文件上传# servlet:# multipart:# max-file-size: 5M# max-request-size: 50M # 热部署 devtools: restart: # 热部署开关 enable: true profiles: active: druid,mybatis 4.2数据源配置-application-druid.yml1234567891011121314151617181920212223242526272829303132333435363738394041424344# 数据源配置spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driverClassName: com.mysql.jdbc.Driver url: \"jdbc:mysql://localhost:3306/db_chinasoftishop?useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8\" username: root password: root # 初始连接数 initialSize: 5 # 最小连接池数量 minIdle: 10 # 最大连接池数量 maxActive: 20 # 配置获取连接等待超时的时间 maxWait: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 timeBetweenEvictionRunsMillis: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 minEvictableIdleTimeMillis: 300000 # 配置一个连接在池中最大生存的时间，单位是毫秒 maxEvictableIdleTimeMillis: 900000 # 配置检测连接是否有效 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false webStatFilter: enabled: true statViewServlet: enabled: true # 设置白名单，不填则允许所有访问 allow: url-pattern: /monitor/druid/* filter: stat: enabled: true # 慢SQL记录 log-slow-sql: true slow-sql-millis: 1000 merge-sql: true wall: config: multi-statement-allow: true 4.3mybatis配置-application-maybatis.yml注：这个其实也可以写在application-druid.yml中,分开只是为了规范 1234567mybatis:# 所要映射的文件 mapper-locations: classpath:mapper/**/*Mapper.xml# 二级缓存 config-location: classpath:mapper/mybatis-config.xml# 模型所关联的包 type-aliases-package: com.czu.domain 4.4二级缓存-mybatis-config.xml的配置1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\" &gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;/settings&gt;&lt;/configuration&gt; 4.5sql映射文件-*Mapper的配置1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.czu.mapper.UserMapper\"&gt; &lt;select id=\"selectByIdUser\" parameterType=\"Long\" resultType=\"User\"&gt; select * from `user` where id=1 &lt;/select&gt;&lt;/mapper&gt; 注：namespace为你所实现接口的具体路径 5、总结以上配置为idea中初部建立SpringBoot的项目的基本配置，后期根据你所做项目在加上具体的配置。","link":"/2019/11/06/Idea%E4%B8%AD%E8%BF%9B%E8%A1%8CSpringBoot%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/"}],"tags":[],"categories":[]}